module LANDFIRE

using HTTP
using JSON3
using Extents
using Dates
using Downloads
using StyledStrings

import GeoInterface as GI

const BASE_URL = "https://lfps.usgs.gov/api"
const HEADER = Dict("Accept" => "application/json", "Content-Type" => "application/json")

#-----------------------------------------------------------------------------# healthcheck
healthcheck() = JSON3.read(HTTP.get("$(BASE_URL)/healthCheck", HEADER).body)

#-----------------------------------------------------------------------------# Products
"""
A struct representing a product in the LANDFIRE API.
- Reference: [https://lfps.usgs.gov/products](https://lfps.usgs.gov/products)
"""
struct Product
    product_name::String
    theme::String
    layer_name::String
    version::String
    conus::Bool
    ak::Bool
    hi::Bool
    geoAreas::String
end
function Base.show(io::IO, p::Product)
    print(io, "Product: ", styled"{bright_cyan:$(p.product_name)} {bright_yellow:$(p.theme)}")
    print(io, styled" {bright_magenta:$(p.layer_name)}, {bright_black:$(p.version)}")
    for k in (:conus, :ak, :hi)
        getfield(p, k) ? print(io, styled" {bright_green:$(k)}") : print(io, styled" {bright_red:$(k)}")
    end
    print(io, " ", p.geoAreas)
end

include("products.jl")


"""
    products(; kw...)

Filter available LANDFIRE products based on keyword arguments.  Boolean arguments are exact matches.
String arguments use substring matches, e.g. using `product_name="Vegetation"` will match all
products with "Vegetation" in the product name.
$(join(["- `$k::$v`" for (k,v) in zip(fieldnames(Product), fieldtypes(Product))], "\n"))
"""
function products(; kw...)
    filter(PRODUCTS) do p
        all(kw) do (k, v)
            val = getfield(p, k)
            val isa Bool ? (val == v) : occursin(v, val)
        end
    end
end

"""
    _update_products!!()

Replace the global `PRODUCTS` variable with the latest data from the LANDFIRE API.
"""
function _update_products!!()
    url = "$BASE_URL/products"
    response = HTTP.get(url, HEADER)
    obj = JSON3.read(response.body)
    global PRODUCTS = map(obj.products) do x
        Product(x.productName, x.theme, x.layerName, x.version, x.conus, x.ak, x.hi, x.geoAreas)
    end
end

# Replace ./products.jl with updated product list
# function generate_products_file()
#     file = joinpath(@__DIR__, "products.jl")
#     open(file, "w") do io
#         println(io, "# This file is autogenerated. Do not edit manually.")
#         println(io, "# Generated at ", Dates.now())
#         println(io, "PRODUCTS::Vector{Product} = [")
#         for p in _update_products!!()
#             print(io, "    Product(")
#             join(io, [repr(getfield(p,k)) for k in fieldnames(Product)], ", ")
#             println(io, "),")
#         end
#         println(io, "]")
#     end
# end


#-----------------------------------------------------------------------------# Jobs
@kwdef struct Job
    email::String = haskey(ENV, "LANDFIRE_EMAIL") ? ENV["LANDFIRE_EMAIL"] : error("Please set LANDFIRE_EMAIL environment variable.")
    layers::Vector{Product}
    area_of_interest::String
    output_projection::Union{Nothing, String} = nothing
    resample_resolution::Union{Nothing, Int} = nothing
    edit_rule::Union{Nothing, String} = nothing
    edit_mask::Union{Nothing, String} = nothing
    priority_code::Union{Nothing, String} = nothing
end

Job(layers::Vector{Product}, aoi; kw...) = Job(; layers, area_of_interest = area_of_interest(aoi), kw...)

area_of_interest(x::Integer) = string(x)
area_of_interest(s::String) = s
area_of_interest((; X, Y)::Extents.Extent) = join(string.([X[1], Y[1], X[2], Y[2]]), ' ')
area_of_interest(geom) = area_of_interest(GI.extent(geom))

#-----------------------------------------------------------------------------# submit
"""
    submit(job::Job) --> job_id::String

Submits a job to the LANDFIRE API.  Returns the job ID as a string.
"""
function submit(job::Job)
    url = BASE_URL * "/job/submit"
    body = filter!(x -> !isnothing(x[2]), Dict(
        "Email" => job.email,
        "Layer_List" => join(map(x -> x.layer_name, job.layers), ';'),
        "Area_of_Interest" => job.area_of_interest,
        (k => getfield(job, k) for k in (:output_projection, :resample_resolution, :edit_rule, :edit_mask, :priority_code))...,
    ))
    res = HTTP.post(url, HEADER, JSON3.write(body))
    return JSON3.read(res.body).jobId
end

#-----------------------------------------------------------------------------# status
"""
    status(job_id::String) --> obj::JSON3.Object

Queries the status of a submitted job.  Returns a JSON3.Object with job details.
If `obj.status == "Succeeded"`, the output zipfile can be downloaded from URL `obj.outputFile`.
"""
function status(job_id::String)
    url = BASE_URL * "/job/status"
    res = HTTP.get(url, HEADER; query=Dict("JobId" => job_id))
    JSON3.read(res.body)
end

#-----------------------------------------------------------------------------# download
"""
    download(layers::Vector{Product}, area_of_interest; every::Integer=5, dest, kw...) --> file::String

Submits a job for the specified `layers` and `area_of_interest`, then polls the job status every `every` seconds.
When the job completes successfully, downloads and returns the path to the output zipfile.  Keyword arguments are passed to the `Job` constructor.
"""
function download(layers::Vector{Product}, aoi; dest=tempname() * ".zip", every::Integer=5, kw...)
    job = Job(layers, aoi; kw...)
    id = submit(job)
    @info "Submitted job with ID: $id.  Checking job every $every seconds."
    while true
        for i in 1:every
            sleep(1)
            print('.')
        end
        obj = status(id)
        @info "Job Status: $(obj.status)"
        if obj.status == "Succeeded"
            file = Downloads.download(obj.outputFile, dest)
            return file
        elseif obj.status == "Failed"
            error("Job failed: $(obj.error)")
        end
    end
end

end # module
